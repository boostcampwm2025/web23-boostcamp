
==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 KRaft 모드 Kafka 클러스터를 구성하고 운영해 본 경험이 있는데, 클러스터 구성 시 어떤 점을 고려했는지 구체적으로 설명해 주세요.
(의도: 대규모 분산 시스템 구축 및 운영 경험 검증)
(태그: Kafka, 클러스터, KRaft)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: KRaft 모드를 선택한 이유는 기존 주키퍼(Zookeeper) 의존성을 제거하여 아키텍처를 경량화하고 관리 포인트를 줄이기 위함이었습니다. 3개의 브로커와 1개의 컨트롤러로 클러스터를 구성해 고가용성을 확보했고, 메타데이터 관리 성능을 개선했습니다. 또한 Docker Compose로 운영 환경과 유사한 로컬 클러스터를 구축해 장애 상황을 시뮬레이션하며 안정성을 검증했습니다.

[Session 1 - Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) 그렇다면 클러스터를 구성할 때 브로커와 컨트롤러의 수를 어떻게 결정했나요?
(의도: 대규모 분산 시스템 구축 및 운영 경험 검증)
(태그: Kafka, 클러스터, KRaft)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 Kafka를 메시지 브로커로 선택한 이유는 무엇이며, Kafka의 어떤 기능을 활용하여 다중 채팅 서버 간 동기화를 구현하였는지 설명해주세요.
(의도: 대규모 분산 시스템 설계 및 구현 능력)
(태그: Kafka, MSA, 채팅 서버)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 채팅 데이터 저장을 위해 MongoDB를 도입한 이유는 무엇인가요?
(의도: 대용량 데이터 처리 경험 검증)
(태그: MongoDB, 채팅 데이터 저장)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변 (Auto): 해당 기술은 트래픽 처리와 확장성을 고려해 선택했습니다. 다양한 레퍼런스를 참고하여 최적의 아키텍처를 설계하고자 노력했습니다.

[Session 1 - Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) 그렇다면 SmileTogether 프로젝트에서 채팅 데이터를 Kafka로 전송하기 위해 사용한 프로토콜은 무엇인가요?
(의도: 실시간 데이터 처리 경험 검증)
(태그: Kafka, STOMP)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변 (Auto): Kafka는 대용량 메시지 처리에 적합하여 선택했습니다. 파티셔닝을 통해 병렬 처리를 극대화했고, 복제본 설정을 통해 고가용성을 확보했습니다.

[Session 1 - Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) Kafka의 메시지 순서 보장을 위해 어떤 방법을 사용했나요?
(의도: Kafka 메시지 처리 경험 검증)
(태그: Kafka, 메시지 순서 보장)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변 (Auto): Kafka는 대용량 메시지 처리에 적합하여 선택했습니다. 파티셔닝을 통해 병렬 처리를 극대화했고, 복제본 설정을 통해 고가용성을 확보했습니다.

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) 리디 콜렉트 서비스를 개발할 때, 다양한 디바이스와 해상도에 대응하기 위해 어떤 전략을 사용했나요?
(의도: 반응형 웹 디자인 및 개발 역량 검증)
(태그: React, Next.js, GraphQL)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Session 1 - Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) 코리아톡을 개발할 때, Socket.io를 사용한 실시간 통신 구현은 어떻게 했나요?
(의도: 실시간 통신 구현 역량 검증)
(태그: React, Socket.io, Recoil)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) 리디 콜렉트를 개발할 때 어떤 기술을 사용했고, 사용자 경험(UX)을 개선하기 위해 어떤 고민을 했나요?
(의도: 프로젝트 경험과 문제 해결 능력 검증)
(태그: React, Next.js, GraphQL, Playwright, Sentry, Datadog)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) 리디 콜렉트 서비스를 개발할 때, 여러 기술을 조합하면서 발생한 기술적 이슈와 그 해결 방안은 무엇이었나요?
(의도: 여러 기술을 조합하여 서비스를 개발하는 능력)
(태그: Next.js, TailwindCSS, Drizzle ORM, PostgreSQL, Docker, Vercel, Supabase)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Max Turns: 10
   - Rate Limit Delay: 20s
   - Log File: interview_test_manual.txt
==========================================


[Session 1 - Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 채팅 메시지의 순서 보장을 위해 Kafka의 어떤 기능을 활용했는지 구체적으로 설명해주세요.
(의도: 대용량 트래픽 처리를 위한 메시징 시스템 활용 경험 검증)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 카프카의 프로듀서 컨슈머 패턴을활용해서 순서 보장을 했습니다.

[Session 1 - Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) 그렇다면 동일한 토픽에 대해서는 파티션이 어떻게 분배되는지 알고 계신가요?
(의도: Kafka의 Partitioning에 대한 구체적인 이해 검증)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 Kafka 메시지 브로커를 사용했는데, Kafka를 선택한 이유와 Topic, Partition 구성은 어떻게 했는지 설명해주세요.
(의도: 대용량 트래픽 대응 경험 검증)
(태그: Kafka, Topic, Partition)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: SmileTogether에서는 채팅 서버를 여러 대로 띄워서 WebSocket 연결 부하를 분산했기 때문에, 특정 서버로 들어온 메시지를 다른 채팅 서버에 연결된 사용자들에게도 동일하게 전달해야 했습니다. 이걸 서버끼리 직접 HTTP로 브로드캐스트하면 서버 수가 늘어날수록 통신이 N:N으로 커지고, 장애가 났을 때 재전송이나 중복 처리 같은 것들을 각 서버가 다 떠안게 돼서 확장과 운영이 어렵다고 봤어요. 그래서 “서버 간 동기화”를 브로커로 분리했는데, Kafka를 선택한 이유는 단순히 Pub/Sub이 필요해서가 아니라, 메시지를 로그처럼 쌓아두고 컨슈머가 오프셋 기반으로 다시 읽을 수 있어서 장애나 재시작 상황에서 재처리가 가능하다는 점이 컸습니다. 채팅은 실시간성이 중요하지만, 서버가 잠깐 내려가거나 리밸런싱이 일어났을 때 메시지가 통째로 사라지면 안 되니까요. 또 채팅에서 중요한 “채널 내 순서”를 설계로 보장하려면 같은 키는 같은 파티션으로 들어가게 만들어야 하는데, Kafka는 key 기반 파티셔닝을 쓰면 파티션 내부 순서가 보장되기 때문에 그 부분도 결정적인 장점이었습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) Kafka에서 메시지 순서를 보장하기 위해 채널 ID를 Key로 해싱해 동일 파티션에 매핑했다고 했는데, 채널 ID가 아닌 다른 키를 사용했을 때의 장단점은 무엇인가요?
(의도: Kafka의 키 기반 파티셔닝 이해 및 활용 능력 검증)
(태그: Kafka, Key-based Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 채널 ID를 키로 잡은 이유는 “같은 채널 안에서는 순서가 절대 깨지면 안 된다”는 요구사항을 Kafka의 보장 단위(파티션) 에 맞춰서 설계한 거예요. 키를 바꾸면 결국 “무엇의 순서를 보장할 건지”가 바뀌고, 그에 따라 장단점이 갈립니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유가 단순히 Pub/Sub이 필요해서가 아니라는데, 구체적으로 어떤 장점이 있었나요?
(의도: Kafka의 실시간 스트리밍 메시징 플랫폼으로서의 장점 이해 및 활용 능력 검증)
(태그: Kafka)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 채팅 메시지 순서를 보장하기 위해 Kafka의 어떤 기능을 활용했는지 구체적으로 설명해주세요.
(의도: 대용량 트래픽 처리를 위한 메시징 시스템의 이해 및 활용 능력)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 Kafka를 메시지 브로커로 선택한 이유와 그 과정에서 발생한 이슈 및 해결 방안은 무엇인가요?
(의도: 대규모 분산 시스템 구축 경험 및 메시지 브로커 활용 능력 검증)
(태그: Kafka, MSA, 채팅 서버)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) FaceFriend 프로젝트에서 하트 요청/수락·거절 및 채팅 실시간 처리를 위해 어떤 기술을 사용했는지 구체적으로 설명해주세요.
(의도: 실시간 통신 기술의 이해 및 활용 능력)
(태그: WebSocket, STOMP)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: websocket과 stomp protocol을 활용했습니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) FaceFriend 프로젝트에서 하트 요청/수락·거절 및 채팅 실시간 처리를 위해 Redis를 STOMP 외부 메시지 브로커로 활용했다고 했는데, 구체적으로 어떤 방식으로 활용했는지 설명해주세요.
(의도: 실시간 통신 기술의 이해 및 활용 능력)
(태그: WebSocket, STOMP, Redis)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 4] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) SmileTogether 프로젝트에서 채팅 메시지 순서를 보장하기 위해 Kafka의 어떤 기능을 활용했는지 구체적으로 설명해주세요.
(의도: 대용량 트래픽 처리를 위한 메시징 시스템의 이해 및 활용 능력)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 다른거

[Turn 5] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 채팅 메시지 순서를 보장하기 위해 Kafka의 어떤 기능을 활용했는지 구체적으로 설명해주세요.
(의도: 대용량 트래픽 처리를 위한 메시징 시스템의 이해 및 활용 능력)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 	exit

[Turn 6] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) SmileTogether 프로젝트에서 채팅 메시지 순서를 보장하기 위해 Kafka의 어떤 기능을 활용했는지 구체적으로 설명해주세요.
(의도: 대용량 트래픽 처리를 위한 메시징 시스템의 이해 및 활용 능력)
(태그: Kafka, Partitioning)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요? 그리고 Kafka의 어떤 기능을 활용하여 다중 채팅 서버 간 동기화를 구현하였는지 설명해주세요.
(의도: 대규모 분산 시스템 구축 경험 및 메시지 브로커 활용 능력 검증)
(태그: Kafka, 다중 채팅 서버, 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇이며, Kafka의 어떤 기능을 활용하여 다중 채팅 서버 간 동기화를 구현하였는지 설명해주세요.
(의도: 대규모 분산 시스템 구축 경험 및 메시지 브로커 활용 능력 검증)
(태그: Kafka, MSA)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) FaceFriend에서 Redis를 STOMP 외부 메시지 브로커로 활용한 이유는 무엇이며, 비연결(미접속) 상태 메시지 손실에 대응하기 위해 어떤 방법을 사용하였는지 설명해주세요.
(의도: 분산 시스템에서의 메시지 처리 및 장애 대응 능력 검증)
(태그: Redis, STOMP)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇이며, Kafka의 어떤 기능을 활용하여 다중 채팅 서버 간 동기화를 구현하였는지 설명해주세요.
(의도: 대규모 분산 시스템 구축 경험 및 메시지 브로커 활용 능력 검증)
(태그: Kafka, MSA)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 Kafka 메시지 브로커를 사용하며 겪은 어려움은 무엇이었고, 이를 어떻게 해결하였나요?
(의도: 대규모 분산 시스템 구축 및 운영 경험)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 안녕하세요. 자기소개 부탁드립니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether 프로젝트에서 Kafka 메시지 브로커를 사용하며 겪은 어려움은 무엇이었고, 이를 어떻게 해결하였나요?
(의도: 대규모 분산 시스템 구축 및 운영 경험)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) FaceFriend 프로젝트에서 Redis를 STOMP 외부 메시지 브로커로 활용하였는데, 구체적으로 어떤 방식으로 구현하였는지 설명해 주세요.
(의도: 분산 시스템 설계 및 구현 경험)
(태그: Redis, FaceFriend)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 4] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) OneHabit 프로젝트에서 하루 인증 3회 제한, 중복 인증 처리 방지를 위해 어떤 기술을 사용하였고, 어떻게 구현하였는지 설명해 주세요.
(의도: 동시성 제어 및 데이터 정합성 유지 경험)
(태그: OneHabit)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 5] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) KiKi_Kiosk 프로젝트에서 관리자 로그인/로그아웃을 구현하며 어떤 기술과 설계 패턴을 적용하였는지 구체적으로 설명해 주세요.
(의도: 설계 패턴 및 보안 기술 적용 경험)
(태그: KiKi_Kiosk)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 사용하며 겪은 어려움은 무엇이었고, 어떻게 해결하였나요?
(의도: 대용량 트래픽 처리 및 메시지 브로커 활용 경험 검증)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 사용하며 겪은 어려움은 무엇이었고, 어떻게 해결하였나요?
(의도: 대규모 트래픽 처리 및 메시지 브로커 활용 경험 검증)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 안녕하세요. 백엔드 개발자입니다. Java와 Spring을 주력으로 사용합니다.Kafka의 파티셔닝 기능을 활용하여 채팅방 ID를 키로 해싱해 순서를 보장했습니다. 하지만 리밸런싱이 일어날 때 순서가 섞이는 문제가 있었습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) Kafka에서 발생한 순서 섞임 문제를 해결하기 위해 어떤 방법을 사용하였나요?
(의도: 대규모 트래픽 처리 및 메시지 브로커 활용 경험 검증)
(태그: Kafka)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: Kafka의 파티셔닝 기능을 활용하여 채팅방 ID를 키로 해싱해 순서를 보장했습니다. 하지만 리밸런싱이 일어날 때 순서가 섞이는 문제가 있었습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) 리밸런싱 시 순서가 섞이는 문제를 해결하기 위해 어떤 방법을 사용하였나요?
(의도: Kafka 활용 경험 및 문제 해결 능력 검증)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: Kafka는 TCP 위에서 동작하므로 단일 파티션 내에서는 순서가 보장됩니다. 따라서 파티션 키를 적절히 설정하여 순서를 유지했습니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) 파티션 키를 설정할 때 어떤 기준으로 하였나요?
(의도: Kafka 활용 경험 및 문제 해결 능력 검증)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: Kafka는 TCP 위에서 동작하므로 단일 파티션 내에서는 순서가 보장됩니다. 따라서 파티션 키를 적절히 설정하여 순서를 유지했습니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) Kafka를 사용하며 느낀 Kafka의 장단점은 무엇인가요?
(의도: 대규모 트래픽 처리 및 메시지 브로커 활용 경험 검증)
(태그: Kafka)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 사용하며 겪은 어려움은 무엇이었고, 어떻게 해결하였나요?
(의도: 대규모 분산 시스템 구축 경험 검증)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 안녕하세요. 자기소개 부탁드립니다. 저는 Java 백엔드 개발자입니다.Kafka의 파티셔닝을 이용해 순서를 보장했습니다. 동일한 키를 가진 메시지는 항상 같은 파티션에 저장되므로, 파티션 내에서는 순서가 보장됩니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (FollowUp) Kafka의 파티셔닝을 이용해 메시지 순서를 보장했는데, Kafka의 어떤 특성 때문에 이것이 가능했나요?
(의도: 분산 시스템의 메시지 브로커 이해)
(태그: Kafka)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요? Kafka의 어떤 특징이 실시간 동기화에 적합하다고 판단했나요?
(태그: Kafka, 실시간 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: Kafka는 높은 처리량과 확장성을 제공하기 때문입니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] Kafka를 사용하면서 겪은 어려움은 무엇이었고, 이를 어떻게 극복했나요? 예를 들어, 메시지 유실이나 순서 보장 문제를 해결한 방법이 궁금합니다.
(태그: Kafka, 실시간 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 메시지 유실/중복 처리 대응

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] Kafka에서 메시지 유실/중복 처리를 위해 어떤 전략을 사용했나요? 예를 들어, 프로듀서와 컨슈머 설정, 토픽 및 파티션 구성 등에 대해 설명해주세요.
(태그: Kafka, 실시간 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요?
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요?
(의도: 기술적 깊이(User vs Engineer))
(근거: 프로젝트 기반 질문(A1). 이력서에서 강조한 프로젝트이며, 기술 선택 이유를 묻고 있음.)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) SmileTogether에서 Kafka 메시지 브로커로 다중 채팅 서버 간 동기화를 구현했다고 하셨는데, 구체적으로 어떤 방식으로 동기화를 이루었는지 설명해주세요.
(의도: undefined)
(근거: undefined)
(태그: Kafka, 다중 채팅 서버, 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 여러 채팅 서버가 동시에 방(Room) 상태를 다루다 보니, 핵심은 **“한 서버에서 발생한 이벤트를 Kafka로 브로드캐스트하고, 모든 서버가 같은 순서/같은 기준으로 반영”**하는 구조로 잡았습니다.

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) 말씀하신 동기화 구조에서 Kafka의 어떤 기능/특성을 활용해 순서와 기준을 보장했나요?
(의도: undefined)
(근거: undefined)
(태그: Kafka, 순서 보장, 기준 보장)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요? 그리고 Kafka 클러스터를 구성하고 운영해 본 경험을 자세히 설명해 주세요.
(의도: 기술적 깊이(User vs Engineer))
(근거: 프로젝트 기반(A1) 질문. 지원자의 기술 선택 이유와 장애 극복 사례를 알고자 함.)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: topic과 파티션 구조입니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) 그 구조에서 각 파티션은 어떤 방식으로 메시지를 분배하나요?
(의도: undefined)
(근거: undefined)
(태그: Kafka, 파티션, 분배)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (Initial) SmileTogether에서 Kafka를 메시지 브로커로 선택한 이유는 무엇인가요?
(의도: 기술적 깊이(User vs Engineer))
(근거: 프로젝트 기반 질문(A1). 이력서의 특정 프로젝트에서 사용한 기술을 선택한 이유와 그 기술의 동작 원리 등을 물어봄으로써, 지원자의 단순 사용 경험을 넘어 원리 이해도와 문제 해결 능력을 확인하고자 함.)
(태그: Kafka, SmileTogether)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]

==========================================
   Clova HCX-003 Manual Interview Test
   - Log File: interview_test_manual.txt
==========================================


[Turn 1] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) SmileTogether에서 Kafka 메시지 브로커로 다중 채팅 서버 간 동기화를 구현했다고 하셨는데, 구체적으로 어떤 방식으로 동기화를 구현했는지 설명해주세요.
(의도: undefined)
(근거: undefined)
(태그: Kafka, 다중 채팅 서버, 동기화)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: SmileTogether에서는 여러 채팅 서버가 동시에 동일한 채팅방 상태를 다뤄야 해서, “상태를 공유한다”기보다 “모든 서버가 같은 이벤트를 같은 기준으로 적용한다”는 이벤트 동기화 모델로 설계했습니다. 클라이언트에서 메시지 전송, 입장/퇴장, 읽음 처리처럼 상태를 바꾸는 행동이 들어오면 해당 서버는 이를 이벤트로 만들고 Kafka에 발행했습니다. 

[Turn 2] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) Kafka에서 메시지 순서를 보장하기 위해 사용한 기술은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Kafka, 메시지 순서 보장)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: Kafka가 순서를 보장하는 단위가 토픽 전체가 아니라 파티션이기 때문에, 이벤트의 key를 roomId로 고정해서 같은 채팅방의 이벤트는 항상 같은 파티션으로 들어가도록 했습니다. 이렇게 하면 채팅방 단위로는 소비 순서가 깨지지 않아서 서버가 여러 대여도 “방 단위 순서 보장”이 가능합니다.

[Turn 3] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) 채팅방 단위로 순서를 보장하기 위해 Kafka의 어떤 속성을 활용했고, 그 장단점은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Kafka, 채팅방, 순서 보장)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 토픽 안에 파티션의 수를 정하고, roomid를 통해서 해싱하고 해시값을 이용해서 sticky하게 매핑할 수 있다는점을 활용했습니다. 장점은 메시지 정합성 문제가 발생하지 않도록 조치한 선에서 카프카의 파티션을 이용할 수 있습니다. 다만, 적정한 파티션의 수를 테스트해야하는 점과 컨슈머 그룹이 다다르기 때문에 상태공유용으로 쓰기에는 성능 측면에서 인프라에 비해 많은 이득을 보기 힘듭니다. 스케일 아웃에서는 강점이 있지만, 이 인프라를 쓴다고 처리 속도가 빨라지는 것은 아닙니다.

[Turn 4] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) 채팅 서버 간 동기화에 사용한 Kafka의 KRaft 모드에 대해 설명해주세요.
(의도: undefined)
(근거: undefined)
(태그: Kafka, KRaft 모드)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 카프카를 관리하는 방식에 가깝습니다. zookeeper사용이 일반적이었으나, 카프카에서 공식적으로 지원을 중단했기 때문에 카프카 인프라의 안정성을 위해서 kraft를 통해서 브로커를 다중화시켜 일종의 클러스터를 만들어 관리했습니다.

[Turn 5] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) Kafka의 KRaft 모드에서 리더 선출 방식과 리더의 역할은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Kafka, KRaft 모드, 리더 선출, 리더 역할)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니다.

[Turn 6] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 Redis를 STOMP 외부 메시지 브로커로 활용했다고 하셨는데, 구체적으로 어떤 방식으로 활용했는지 설명해주세요.
(의도: undefined)
(근거: undefined)
(태그: Redis, STOMP, 외부 메시지 브로커)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 말그대로 redis의 pub/sub 기능을 활용해서 외부 메시지 브로커로 동작하게 했습니다. 

[Turn 7] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 Redis를 외부 메시지 브로커로 사용한 이유는 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Redis, 외부 메시지 브로커)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 일단은 확장 가능성을 생각했습니다. 채팅 기능이 있는 만큼 스케일업으로는  한계가 있다고  판단했고, 이에 외부 메시지 브로커로 처리하는 게 안정성이나 확장성 부분에서 이득이 있다고 판단했습니다. 특히, 톰캣을 사용하다 보니 스레드 관리 부분에서 문제가 발생할 위험이 있다고 판단했고 이에 redis를 통해서 밖으로 빼서 같은 서버에서 동작하더라도 프로세스가 다르므로 최대한 스레드 점유가 안되도록 하려 했습니다.

[Turn 8] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 Redis를 외부 메시지 브로커로 사용하면서 발생한 문제점과 이를 해결한 방법은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Redis, 외부 메시지 브로커)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 메시지 유실 문제가 발생해서 key-value 스토어에 value를 리스트형태로 두어서 유실 메시지를 관리했습니다.

[Turn 9] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 Redis를 외부 메시지 브로커로 사용하면서 발생한 메시지 유실 문제를 해결하기 위해 어떤 방법을 사용했나요?
(의도: undefined)
(근거: undefined)
(태그: Redis, 외부 메시지 브로커, 메시지 유실)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 아까 말했던 대로 리스트형태로 두어서 유실된 메시지를 보관하다가 클라이언트가 웹소켓이 연결되면 보내주는 방식을 이용했습니다. 

[Turn 10] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 Redis를 외부 메시지 브로커로 사용하면서 발생한 메시지 유실 문제를 해결하기 위해 사용한 기술은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: Redis, 외부 메시지 브로커, 메시지 유실)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
👉 지원자 답변: 모르겠습니디.

[Turn 11] ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[면접관] (undefined) FaceFriend에서 사용한 STOMP의 버전은 무엇인가요?
(의도: undefined)
(근거: undefined)
(태그: STOMP)
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

[User exited manually]
